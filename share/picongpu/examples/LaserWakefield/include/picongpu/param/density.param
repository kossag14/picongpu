/* Copyright 2013-2017 Axel Huebl, Rene Widera, Felix Schmitt,
 *                     Richard Pausch, Marco Garten
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/particles/densityProfiles/profiles.def"
/* preprocessor struct generator */
#include <pmacc/preprocessor/struct.hpp>

namespace picongpu
{
namespace SI
{
    /** Base density in particles per m^3 in the density profiles.
     *
     * This is often taken as reference maximum density in normalized profiles.
     * Individual particle species can define a `densityRatio` flag relative
     * to this value.
     *
     * unit: ELEMENTS/m^3
     */
#ifndef PARAM_BASE_DENSITY_SI
#   define PARAM_BASE_DENSITY_SI 1.e25
#endif
     constexpr float_64 BASE_DENSITY_SI = PARAM_BASE_DENSITY_SI;
}

namespace densityProfiles
{
    PMACC_STRUCT(GaussianParameter,
        /** Profile Formula:
         *   constexpr float_X exponent = abs((y - gasCenter_SI) / gasSigma_SI);
         *   constexpr float_X density = exp(gasFactor * pow(exponent, gasPower));
         *
         *   takes `gasCenterLeft_SI      for y < gasCenterLeft_SI`,
         *         `gasCenterRight_SI     for y > gasCenterRight_SI`,
         *   and exponent = float_X(0.0)  for gasCenterLeft_SI < y < gasCenterRight_SI
         */
        (PMACC_C_VALUE(float_X, gasFactor, -1.0))
        (PMACC_C_VALUE(float_X, gasPower, 4.0))

        /** height of vacuum area on top border
         *
         *  this vacuum is important because of the laser initialization,
         *  which is done in the first cells of the simulation and
         *  assumes a charge-free volume
         *  unit: cells
         */
        (PMACC_C_VALUE(uint32_t, vacuumCellsY, 50))

        /** The central position of the gas distribution
          *  unit: meter
          */
        (PMACC_C_VALUE(float_64, gasCenterLeft_SI, 8.0e-5))
        (PMACC_C_VALUE(float_64, gasCenterRight_SI, 10.0e-5))

        /** the distance from gasCenter_SI until the gas density decreases to its 1/e-th part
          *  unit: meter
          */
        (PMACC_C_VALUE(float_64, gasSigmaLeft_SI, 8.0e-5))
        (PMACC_C_VALUE(float_64, gasSigmaRight_SI, 8.0e-5))
    ); /* struct GaussianParam */

    /* definition of density with Gaussian profile */
    using Gaussian = GaussianImpl< GaussianParameter >;

    PMACC_STRUCT(GaussianCloudParam,
        /** Profile Formula:
         *     exponent = |globalCellPos - center| / sigma
         *     density = e^[ gasFactor * exponent^gasPower ]
         */
        (PMACC_C_VALUE(float_X, gasFactor, -0.5))
        (PMACC_C_VALUE(float_X, gasPower, 2.0))

        /** height of vacuum area on top border
         *
         * this vacuum is important because of the laser initialization,
         * which is done in the first cell of the simulation
         * unit: cells
         */
        (PMACC_C_VALUE(uint32_t, vacuumCellsY, 50))

        /** The central position of the density distribution
         *  unit: meter
         */
        (PMACC_C_VECTOR_DIM(float_64, simDim, center_SI, 1.024e-5, 9.072e-5, 1.024e-5))

        /** the distance from gasCenter_SI until the density decreases to its 1/e-th part
          *  unit: meter */
        (PMACC_C_VECTOR_DIM(float_64, simDim, sigma_SI, 6.0e-6, 6.0e-6, 6.0e-6))
    ); /* struct GaussianCloudParam */

    /* definition of cloud profile */
    using GaussianCloud = GaussianCloudImpl< GaussianCloudParam >;


     struct FreeFormulaFunctor
     {
         /** This formula uses SI quantities only.
          *  The profile will be multiplied by BASE_DENSITY_SI.
          *
          * @param position_SI total offset including all slides [meter]
          * @param cellSize_SI cell sizes [meter]
          *
          * @return float_X density [normalized to 1.0]
          */
         HDINLINE float_X
         operator()(
             const floatD_64& position_SI,
             const float3_64& cellSize_SI
         )
         {
             const float_64 y = position_SI.y();
             const float_64 z = position_SI.z();
 
             /** height of vacuum area on bottom border
              *      this vacuum is really important because of the laser initialization, 
              *      which is done in the first cell of the simulation
              *  unit: meter */
             constexpr float_64 VACUUM_Y_SI = 100.0 * picongpu::SI::CELL_HEIGHT_SI;
             constexpr float_64 VACUUM_Z_SI = 148.0 * picongpu::SI::CELL_DEPTH_SI;
             constexpr float_64 Z_GRADIENT_SI = 32.0 * picongpu::SI::CELL_DEPTH_SI;
            //constexpr float_64 SIM_BOX_Z = 3744.0 * picongpu::SI::CELL_DEPTH_SI; // MATCH THIS WITH Z-COMPONENT OF "TBG_gridsize" IN CFG_FILE !!!
             constexpr float_64 SIM_BOX_Z = 3072.0 * picongpu::SI::CELL_DEPTH_SI; // MATCH THIS WITH Z-COMPONENT OF "TBG_gridsize" IN CFG_FILE !!!
             constexpr float_64 PLASMA_Z_LENGTH_SI = SIM_BOX_Z - float_X( 2.0 ) * VACUUM_Z_SI;
             constexpr float_64 INITIAL_UPRAMP = 20.0e-6; // unit: meter
             constexpr float_64 HIGH_DENSITY_PLATEAU = 80.0e-6; // unit: meter

             #ifndef PARAM_DOWNRAMP_ALL
             #   define PARAM_DOWNRAMP_ALL 5.0e-6 // unit: meter
             #endif
             #ifndef PARAM_FACTOR_DENSITY_END
             #   define PARAM_FACTOR_DENSITY_END 1.0 
             #endif
             
             constexpr float_64 DOWNRAMP_1 = 0.29289322*PARAM_DOWNRAMP_ALL; // unit: meter
             constexpr float_64 DOWNRAMP_2 = PARAM_DOWNRAMP_ALL/1.41421356; // unit: meter
 
             constexpr float_64 REL_DENSITY_1 = 2.0; // Old value of previous TWEAC scenarios was: 2.0
             constexpr float_64 REL_DENSITY_2 = 1.41421356; // sqrt(2.), old value was: sqrt(2.0)
             constexpr float_64 REL_DENSITY_3 = PARAM_FACTOR_DENSITY_END; 
             float_X temp = float_X(1.0);
    
     /* Alexander Debus description of the density profile
        The correct gas profile should be: 
        B) (after initial vacuum) upramp until 20um to relative density of 2.0, 
        C) high density plateau at 2.0 rel. density until 100um, 
        D) first density downramp until 110um to rel. density sqrt(2.0), 
        E) second density downramp until 140um to rel. density 1.0 (the base density), 
        F) everything stays at the base density.
         */
     /* Plot of density profile

        density
         2.0_|     ___ 
         1.4_|    /   \
             |   /     `. 
         1.0_|  /        `._______
             | /
             |----------------------------  y
             A B   C D E    F
         */
     // vacuum before gas (A)
            if ( y < VACUUM_Y_SI )
                return float_X(0.0);

         // first up-ramp (B)
            if ( y >= ( VACUUM_Y_SI ) && y < ( VACUUM_Y_SI + INITIAL_UPRAMP ) )
                return temp * float_X(REL_DENSITY_1) * float_X( ( y - VACUUM_Y_SI ) / INITIAL_UPRAMP );
         // first plateau (C)
            if ( y >= ( VACUUM_Y_SI + INITIAL_UPRAMP ) && y < ( VACUUM_Y_SI + INITIAL_UPRAMP + HIGH_DENSITY_PLATEAU) )
                return temp * float_X(REL_DENSITY_1) ;
         // first down-ramp (D)
            if ( y >= ( VACUUM_Y_SI + INITIAL_UPRAMP + HIGH_DENSITY_PLATEAU ) && y < ( VACUUM_Y_SI + INITIAL_UPRAMP + HIGH_DENSITY_PLATEAU + DOWNRAMP_1 ) )
                return temp*float_X( ( 1.0 - ( y - VACUUM_Y_SI - INITIAL_UPRAMP - HIGH_DENSITY_PLATEAU ) / DOWNRAMP_1 ) * ( REL_DENSITY_1 - REL_DENSITY_2 ) + REL_DENSITY_2 );
         // second down-ramp (E)
            if ( y >= (VACUUM_Y_SI + INITIAL_UPRAMP + HIGH_DENSITY_PLATEAU + DOWNRAMP_1 ) && y < (VACUUM_Y_SI + INITIAL_UPRAMP + HIGH_DENSITY_PLATEAU + DOWNRAMP_1 + DOWNRAMP_2 ) )
                return temp*float_X( ( 1.0 - ( y - VACUUM_Y_SI - INITIAL_UPRAMP - HIGH_DENSITY_PLATEAU - DOWNRAMP_1 ) / DOWNRAMP_2 ) * ( REL_DENSITY_2 - REL_DENSITY_3 )  + REL_DENSITY_3 );
         // second plateau (F)
            if ( y >= ( VACUUM_Y_SI + INITIAL_UPRAMP + HIGH_DENSITY_PLATEAU + DOWNRAMP_1 + DOWNRAMP_2 ) )
                return temp * float_X( REL_DENSITY_3 ); // 0.32+e19 cm^-3
             return float_X(temp);
         }
     };
 
     /* definition of density with Gaussian profile */
using FreeFormula = FreeFormulaImpl< FreeFormulaFunctor >;


struct FoilFunctor
{

    /**
     * This formula uses SI quantities only
     * The profile will be multiplied by BASE_DENSITY_SI.
     *
     * @param position_SI total offset including all slides [in meter]
     * @param cellSize_SI cell sizes [in meter]
     *
     * @return float_X density [normalized to 1.0]
     */
    HDINLINE float_X operator()(
        float2_64 pos,
        const float3_64& cellSize_SI
    )
    {
        /* center point of foil */
        constexpr float_64 plateauPos = 4e-6;
        /* thickness of foil */
        constexpr float_64 plateauLength = 2e-6;
        /* gaussian ramp length of density above the surface */
        constexpr float_64 rampLength = 0.1e-6;

        using namespace pmacc::algorithms::math;

        if( abs( pos.y() - plateauPos) < plateauLength / 2.0 )
        {
            return 1.0_X;
        }
        const float_64 d = math::min(
            abs( pos.y() - plateauPos + plateauLength / 2.0 ),
            abs( pos.y() - plateauPos - plateauLength / 2.0 )
        );
        return float_X( exp( -d * d / ( 2.0_X * rampLength * rampLength ) ) );
    }
};

//! definition of free formula profile
using Foil = FreeFormulaImpl< FoilFunctor >;


struct FlatFoilWithRampFunctor
    {
        /** This formula uses SI quantities only.
         *  The profile will be multiplied by BASE_DENSITY_SI.
         *
         * @param position_SI total offset including all slides [meter]
         * @param cellSize_SI cell sizes [meter]
         *
         * @return float_X density [normalized to 1.0]
         */
        HDINLINE float_X
        operator()(
            const floatD_64& position_SI,
            const float3_64& cellSize_SI
        )
        {
            // m -> mu
            const float_64 y( position_SI.y() * 1.e6 );

            // target begin & end (plateau)
            constexpr float_64 y0( 0.5 );
            constexpr float_64 y1( y0 + 1.0 );
            // exponential pre-expanded density
            constexpr float_64 L( 10.e-3 );
            constexpr float_64 L_cutoff( 4. * L );

            float_64 dens = 0.0;

            // upramp
            if( y < y0 && (y0 - y) < L_cutoff )
                dens = math::exp( ( y - y0 ) / L );
            // downramp
            if( y > y1 && (y - y1) < L_cutoff )
                dens = math::exp( ( y1 - y ) / L );
            // plateau
            if( y >= y0 && y <= y1 )
                dens = 1.0;

            // safety check: all parts of the function MUST be > 0
            dens *= float_64( dens >= 0.0 );
            return dens;
        }
    };

    // definition of free formula profile
    using FlatFoilWithRamp = FreeFormulaImpl< FlatFoilWithRampFunctor >;

    // put probe particles every 4th cell in X, Y(, Z)
    using ProbeEveryFourthCell = EveryNthCellImpl<
        mCT::UInt32<
            4,
            4,
            4
        >
    >;


}
}
